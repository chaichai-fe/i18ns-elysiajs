import * as t from '@sinclair/typebox';
import * as z from 'zod';
function FromAny(_type) {
    return z.any();
}
function FromArray(type) {
    const constraints = [];
    const { minItems, maxItems /* minContains, maxContains, contains */ } = type;
    if (t.ValueGuard.IsNumber(minItems))
        constraints.push((input) => input.min(minItems));
    if (t.ValueGuard.IsNumber(maxItems))
        constraints.push((input) => input.max(maxItems));
    const mapped = z.array(FromType(type.items));
    return constraints.reduce((type, constraint) => constraint(type), mapped);
}
function FromBigInt(_type) {
    return z.bigint();
}
function FromBoolean(_type) {
    return z.boolean();
}
function FromDate(_type) {
    return z.date();
}
function FromFunction(type) {
    const mappedParameters = FromTypes(type.parameters);
    return z.function(z.tuple(mappedParameters), FromType(type.returns));
}
function FromInteger(type) {
    const { exclusiveMaximum, exclusiveMinimum, minimum, maximum, multipleOf } = type;
    const constraints = [(value) => value.int()];
    if (t.ValueGuard.IsNumber(exclusiveMinimum))
        constraints.push((input) => input.min(exclusiveMinimum + 1));
    if (t.ValueGuard.IsNumber(exclusiveMaximum))
        constraints.push((input) => input.min(exclusiveMaximum - 1));
    if (t.ValueGuard.IsNumber(maximum))
        constraints.push((input) => input.max(maximum));
    if (t.ValueGuard.IsNumber(minimum))
        constraints.push((input) => input.min(minimum));
    if (t.ValueGuard.IsNumber(multipleOf))
        constraints.push((input) => input.multipleOf(multipleOf));
    return constraints.reduce((input, constraint) => constraint(input), z.number());
}
function FromIntersect(type) {
    return type.allOf.reduce((result, left) => {
        return z.intersection(FromType(left), result);
    }, z.unknown());
}
function FromLiteral(type) {
    return z.literal(type.const);
}
// prettier-ignore
function FromObject(type) {
    const constraints = [];
    const { additionalProperties } = type;
    if (additionalProperties === false)
        constraints.push((input) => input.strict());
    if (t.KindGuard.IsSchema(additionalProperties))
        constraints.push((input) => input.catchall(FromType(additionalProperties)));
    const properties = globalThis.Object.getOwnPropertyNames(type.properties).reduce((result, key) => ({ ...result, [key]: FromType(type.properties[key]) }), {});
    return constraints.reduce((type, constraint) => constraint(type), z.object(properties));
}
function FromPromise(type) {
    return z.promise(FromType(type.item));
}
function FromRegExp(type) {
    const constraints = [(input) => input.regex(new RegExp(type.source), type.flags)];
    const { minLength, maxLength } = type;
    if (t.ValueGuard.IsNumber(maxLength))
        constraints.push((input) => input.max(maxLength));
    if (t.ValueGuard.IsNumber(minLength))
        constraints.push((input) => input.min(minLength));
    return constraints.reduce((type, constraint) => constraint(type), z.string());
}
// prettier-ignore
function FromRecord(type) {
    const pattern = globalThis.Object.getOwnPropertyNames(type.patternProperties)[0];
    const value = FromType(type.patternProperties[pattern]);
    return (pattern === t.PatternBooleanExact ? z.record(z.boolean(), value) :
        pattern === t.PatternNumberExact ? z.record(z.number(), value) :
            pattern === t.PatternStringExact ? z.record(z.string(), value) :
                z.record(z.string().regex(new RegExp(pattern)), value));
}
function FromNever(type) {
    return z.never();
}
function FromNull(_type) {
    return z.null();
}
function FromNumber(type) {
    const { exclusiveMaximum, exclusiveMinimum, minimum, maximum, multipleOf } = type;
    const constraints = [];
    if (t.ValueGuard.IsNumber(exclusiveMinimum))
        constraints.push((input) => input.min(exclusiveMinimum + 1));
    if (t.ValueGuard.IsNumber(exclusiveMaximum))
        constraints.push((input) => input.min(exclusiveMaximum - 1));
    if (t.ValueGuard.IsNumber(maximum))
        constraints.push((input) => input.max(maximum));
    if (t.ValueGuard.IsNumber(minimum))
        constraints.push((input) => input.min(minimum));
    if (t.ValueGuard.IsNumber(multipleOf))
        constraints.push((input) => input.multipleOf(multipleOf));
    return constraints.reduce((input, constraint) => constraint(input), z.number());
}
// prettier-ignore
function FromString(type) {
    const constraints = [];
    const { minLength, maxLength, pattern, format } = type;
    if (t.ValueGuard.IsNumber(maxLength))
        constraints.push((input) => input.max(maxLength));
    if (t.ValueGuard.IsNumber(minLength))
        constraints.push((input) => input.min(minLength));
    if (t.ValueGuard.IsString(pattern))
        constraints.push((input) => input.regex(new RegExp(pattern)));
    if (t.ValueGuard.IsString(format))
        constraints.push((input) => format === 'base64' ? input.base64() :
            format === 'base64url' ? input.base64url() :
                format === 'cidrv4' ? input.cidr({ version: 'v4' }) :
                    format === 'cidrv6' ? input.cidr({ version: 'v6' }) :
                        format === 'cidr' ? input.cidr() :
                            format === 'cuid' ? input.cuid() :
                                format === 'cuid2' ? input.cuid2() :
                                    format === 'date' ? input.date() :
                                        format === 'datetime' ? input.datetime() :
                                            format === 'duration' ? input.duration() :
                                                format === 'email' ? input.email() :
                                                    format === 'emoji' ? input.emoji() :
                                                        format === 'ipv4' ? input.ip({ version: 'v4' }) :
                                                            format === 'ipv6' ? input.ip({ version: 'v6' }) :
                                                                format === 'ip' ? input.ip() :
                                                                    format === 'jwt' ? input.jwt() :
                                                                        format === 'nanoid' ? input.nanoid() :
                                                                            format === 'time' ? input.time() :
                                                                                format === 'ulid' ? input.ulid() :
                                                                                    format === 'url' ? input.url() :
                                                                                        format === 'uuid' ? input.uuid() :
                                                                                            input);
    return constraints.reduce((type, constraint) => constraint(type), z.string());
}
function FromSymbol(_type) {
    return z.symbol();
}
function FromTuple(type) {
    const mapped = FromTypes(type.items || []);
    return z.tuple(mapped);
}
function FromUndefined(_type) {
    return z.undefined();
}
function FromUnion(_type) {
    const mapped = FromTypes(_type.anyOf);
    return mapped.length >= 1 ? z.union(mapped) : z.never();
}
function FromUnknown(_type) {
    return z.unknown();
}
function FromVoid(_type) {
    return z.void();
}
function FromTypes(types) {
    return types.map((type) => FromType(type));
}
// prettier-ignore
function FromType(type) {
    const constraints = [];
    if (!t.ValueGuard.IsUndefined(type.description))
        constraints.push(input => input.describe(type.description));
    if (!t.ValueGuard.IsUndefined(type.default))
        constraints.push(input => input.default(type.default));
    const mapped = constraints.reduce((type, constraint) => constraint(type), (t.KindGuard.IsAny(type) ? FromAny(type) :
        t.KindGuard.IsArray(type) ? FromArray(type) :
            t.KindGuard.IsBigInt(type) ? FromBigInt(type) :
                t.KindGuard.IsBoolean(type) ? FromBoolean(type) :
                    t.KindGuard.IsDate(type) ? FromDate(type) :
                        t.KindGuard.IsFunction(type) ? FromFunction(type) :
                            t.KindGuard.IsInteger(type) ? FromInteger(type) :
                                t.KindGuard.IsIntersect(type) ? FromIntersect(type) :
                                    t.KindGuard.IsLiteral(type) ? FromLiteral(type) :
                                        t.KindGuard.IsNever(type) ? FromNever(type) :
                                            t.KindGuard.IsNull(type) ? FromNull(type) :
                                                t.KindGuard.IsNumber(type) ? FromNumber(type) :
                                                    t.KindGuard.IsObject(type) ? FromObject(type) :
                                                        t.KindGuard.IsPromise(type) ? FromPromise(type) :
                                                            t.KindGuard.IsRegExp(type) ? FromRegExp(type) :
                                                                t.KindGuard.IsRecord(type) ? FromRecord(type) :
                                                                    t.KindGuard.IsString(type) ? FromString(type) :
                                                                        t.KindGuard.IsSymbol(type) ? FromSymbol(type) :
                                                                            t.KindGuard.IsTuple(type) ? FromTuple(type) :
                                                                                t.KindGuard.IsUndefined(type) ? FromUndefined(type) :
                                                                                    t.KindGuard.IsUnion(type) ? FromUnion(type) :
                                                                                        t.KindGuard.IsUnknown(type) ? FromUnknown(type) :
                                                                                            t.KindGuard.IsVoid(type) ? FromVoid(type) :
                                                                                                z.never()));
    // Modifier Mapping
    const isOptional = t.KindGuard.IsOptional(type);
    const isReadonly = t.KindGuard.IsReadonly(type);
    const result = (isOptional && isReadonly ? z.optional(mapped) :
        isOptional && !isReadonly ? z.optional(mapped) :
            !isOptional && isReadonly ? mapped :
                mapped);
    return result;
}
/** Creates a Zod type from TypeBox */
export function ZodFromTypeBox(type) {
    return FromType(type);
}
