import * as t from '@sinclair/typebox';
import * as z from 'zod';
type TFromAny<Result = z.ZodAny> = Result;
type TFromArray<Type extends t.TSchema, Result = z.ZodArray<TFromType<Type>>> = Result;
type TFromBigInt<Result = z.ZodBigInt> = Result;
type TFromBoolean<Result = z.ZodBoolean> = Result;
type TFromDate<Result = z.ZodDate> = Result;
type TFromFunction<Parameters extends t.TSchema[], ReturnType extends t.TSchema, MappedParameters extends z.ZodTypeAny[] = TFromTypes<Parameters>> = (MappedParameters extends [z.ZodTypeAny, ...z.ZodTypeAny[]] | [] ? z.ZodFunction<z.ZodTuple<MappedParameters>, TFromType<ReturnType>> : z.ZodNever);
type TFromInteger<Result = z.ZodNumber> = Result;
type TFromIntersect<Types extends t.TSchema[], Result extends z.ZodTypeAny = z.ZodUnknown> = (Types extends [infer Left extends t.TSchema, ...infer Right extends t.TSchema[]] ? TFromIntersect<Right, z.ZodIntersection<TFromType<Left>, Result>> : Result);
type TFromLiteral<Value extends t.TLiteralValue, Result = z.ZodLiteral<Value>> = Result;
type TFromObject<Properties extends t.TProperties, Result = z.ZodObject<{
    [Key in keyof Properties]: TFromType<Properties[Key]>;
}>> = Result;
type TFromPromise<Type extends t.TSchema, Result = z.ZodPromise<TFromType<Type>>> = Result;
type TFromRegExp<Result = z.ZodString> = Result;
type TFromRecord<Key extends t.TSchema, Value extends t.TSchema> = (TFromType<Key> extends infer ZodKey extends z.KeySchema ? z.ZodRecord<ZodKey, TFromType<Value>> : z.ZodNever);
type TFromNever<Result = z.ZodNever> = Result;
type TFromNull<Result = z.ZodNull> = Result;
type TFromNumber<Result = z.ZodNumber> = Result;
type TFromString<Result = z.ZodString> = Result;
type TFromSymbol<Result = z.ZodSymbol> = Result;
type TFromTuple<Types extends t.TSchema[], Mapped extends z.ZodTypeAny[] = TFromTypes<Types>> = (Mapped extends [z.ZodTypeAny, ...z.ZodTypeAny[]] | [] ? z.ZodTuple<Mapped> : z.ZodNever);
type TFromUndefined<Result = z.ZodUndefined> = Result;
type TFromUnion<Types extends t.TSchema[], Mapped extends z.ZodTypeAny[] = TFromTypes<Types>> = (Mapped extends z.ZodUnionOptions ? z.ZodUnion<Mapped> : z.ZodNever);
type TFromUnknown<Result = z.ZodUnknown> = Result;
type TFromVoid<Result = z.ZodVoid> = Result;
type TFromTypes<Types extends t.TSchema[], Result extends z.ZodTypeAny[] = []> = (Types extends [infer Left extends t.TSchema, ...infer Right extends t.TSchema[]] ? TFromTypes<Right, [...Result, TFromType<Left>]> : Result);
type TFromType<Type extends t.TSchema, Mapped extends z.ZodTypeAny | z.ZodEffects<any> = (Type extends t.TAny ? TFromAny : Type extends t.TArray<infer Type extends t.TSchema> ? TFromArray<Type> : Type extends t.TBigInt ? TFromBigInt : Type extends t.TBoolean ? TFromBoolean : Type extends t.TDate ? TFromDate : Type extends t.TFunction<infer Parameters extends t.TSchema[], infer ReturnType extends t.TSchema> ? TFromFunction<Parameters, ReturnType> : Type extends t.TInteger ? TFromInteger : Type extends t.TIntersect<infer Types extends t.TSchema[]> ? TFromIntersect<Types> : Type extends t.TLiteral<infer Value extends t.TLiteralValue> ? TFromLiteral<Value> : Type extends t.TNever ? TFromNever : Type extends t.TNull ? TFromNull : Type extends t.TNumber ? TFromNumber : Type extends t.TObject<infer Properties extends t.TProperties> ? TFromObject<Properties> : Type extends t.TPromise<infer Type extends t.TSchema> ? TFromPromise<Type> : Type extends t.TRecord<infer Key extends t.TSchema, infer Value extends t.TSchema> ? TFromRecord<Key, Value> : Type extends t.TRegExp ? TFromRegExp : Type extends t.TString ? TFromString : Type extends t.TSymbol ? TFromSymbol : Type extends t.TTuple<infer Types extends t.TSchema[]> ? TFromTuple<Types> : Type extends t.TUndefined ? TFromUndefined : Type extends t.TUnion<infer Types extends t.TSchema[]> ? TFromUnion<Types> : Type extends t.TUnknown ? TFromUnknown : Type extends t.TVoid ? TFromVoid : z.ZodNever), IsReadonly extends boolean = Type extends t.TReadonly<t.TSchema> ? true : false, IsOptional extends boolean = Type extends t.TOptional<t.TSchema> ? true : false, Result extends z.ZodTypeAny | z.ZodEffects<any> = ([
    IsReadonly,
    IsOptional
] extends [true, true] ? z.ZodReadonly<z.ZodOptional<Mapped>> : [
    IsReadonly,
    IsOptional
] extends [false, true] ? z.ZodOptional<Mapped> : [
    IsReadonly,
    IsOptional
] extends [true, false] ? z.ZodReadonly<Mapped> : Mapped)> = Result;
/** Creates a Zod type from TypeBox */
export type TZodFromTypeBox<Type extends t.TSchema, Result extends z.ZodTypeAny | z.ZodEffects<any> = TFromType<Type>> = Result;
/** Creates a Zod type from TypeBox */
export declare function ZodFromTypeBox<Type extends t.TSchema>(type: Type): TZodFromTypeBox<Type>;
export {};
