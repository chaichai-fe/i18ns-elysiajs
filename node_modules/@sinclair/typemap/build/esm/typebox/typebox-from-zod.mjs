import * as t from '@sinclair/typebox';
import * as z from 'zod';
// ------------------------------------------------------------------
// Options
// ------------------------------------------------------------------
function Options(type) {
    const description = t.ValueGuard.IsUndefined(type.description) ? {} : { description: type.description };
    return { ...description };
}
// ------------------------------------------------------------------
// Formats
// ------------------------------------------------------------------
const check = (type, value) => type.safeParse(value).success;
t.FormatRegistry.Set('base64', (value) => check(z.string().base64(), value));
t.FormatRegistry.Set('base64url', (value) => check(z.string().base64url(), value));
t.FormatRegistry.Set('cidrv4', (value) => check(z.string().cidr({ version: 'v4' }), value));
t.FormatRegistry.Set('cidrv6', (value) => check(z.string().cidr({ version: 'v6' }), value));
t.FormatRegistry.Set('cidr', (value) => check(z.string().cidr(), value));
t.FormatRegistry.Set('cuid', (value) => check(z.string().cuid(), value));
t.FormatRegistry.Set('cuid2', (value) => check(z.string().cuid2(), value));
t.FormatRegistry.Set('date', (value) => check(z.string().date(), value));
t.FormatRegistry.Set('datetime', (value) => check(z.string().datetime({ offset: true }), value));
t.FormatRegistry.Set('duration', (value) => check(z.string().duration(), value));
t.FormatRegistry.Set('email', (value) => check(z.string().email(), value));
t.FormatRegistry.Set('emoji', (value) => check(z.string().emoji(), value));
t.FormatRegistry.Set('ipv4', (value) => check(z.string().ip({ version: 'v4' }), value));
t.FormatRegistry.Set('ipv6', (value) => check(z.string().ip({ version: 'v6' }), value));
t.FormatRegistry.Set('ip', (value) => check(z.string().ip(), value));
t.FormatRegistry.Set('jwt', (value) => check(z.string().jwt(), value));
t.FormatRegistry.Set('nanoid', (value) => check(z.string().nanoid(), value));
t.FormatRegistry.Set('time', (value) => check(z.string().time(), value));
t.FormatRegistry.Set('ulid', (value) => check(z.string().ulid(), value));
t.FormatRegistry.Set('url', (value) => check(z.string().url(), value));
t.FormatRegistry.Set('uuid', (value) => check(z.string().uuid(), value));
function FromAny(_def) {
    return t.Any();
}
function FromArray(def) {
    const minItems = def.minLength === null ? {} : { minItems: def.minLength.value };
    const maxItems = def.maxLength === null ? {} : { minItems: def.maxLength.value };
    const options = { ...minItems, ...maxItems };
    return t.Array(FromType(def.type), options);
}
function FromBigInt(def) {
    return t.BigInt();
}
function FromBoolean(def) {
    return t.Boolean();
}
function FromDate(def) {
    return t.Date();
}
function FromDefault(def) {
    return t.CloneType(FromType(def.innerType), { default: def.defaultValue() });
}
function FromDiscriminatedUnion(def) {
    const types = def.options.map((type) => FromType(type));
    return t.Union(types, { discriminator: def.discriminator });
}
function FromEffects(type) {
    return t
        .Transform(FromType(type._def.schema))
        .Decode((value) => type.parse(value))
        .Encode((_) => {
        throw Error('Encode not implemented for Zod types');
    });
}
function FromEnum(def) {
    const variants = def.values.map((value) => t.Literal(value));
    return t.Union(variants);
}
function FromLiteral(def) {
    return t.Literal(def.value);
}
function FromIntersect(type) {
    return t.Intersect([FromType(type.left), FromType(type.right)]);
}
function FromObject(def, shape) {
    const additionalProperties = def.unknownKeys === 'strict' ? { additionalProperties: false } : {};
    const options = { ...additionalProperties };
    return t.Object(globalThis.Object.keys(shape).reduce((properties, key) => {
        return { ...properties, [key]: FromType(shape[key]) };
    }, {}), options);
}
function FromOptional(def) {
    return t.Optional(FromType(def.innerType));
}
function FromPromise(def) {
    return t.Promise(FromType(def.type));
}
function FromNullable(def) {
    return t.Union([t.Null(), FromType(def.innerType)]);
}
// prettier-ignore
function FromNumber(def) {
    const options = def.checks.reduce((options, check) => {
        return { ...options, ...(check.kind === 'int' ? { multipleOf: 1 } :
                check.kind === 'max' ? check.inclusive ? { maximum: check.value } : { exclusiveMaximum: check.value } :
                    check.kind === 'min' ? check.inclusive ? { minimum: check.value } : { exclusiveMinimum: check.value } :
                        check.kind === 'multipleOf' ? { multipleOf: check.value } :
                            {}) };
    }, {});
    return t.Number(options);
}
function FromNever(def) {
    return t.Never();
}
function FromNull(def) {
    return t.Null();
}
function FromReadonly(def) {
    return t.Readonly(FromType(def.innerType));
}
function FromRecord(def) {
    return t.Record(FromType(def.keyType), FromType(def.valueType));
}
// prettier-ignore
function FromString(def) {
    const options = def.checks.reduce((options, check) => {
        return { ...options, ...(check.kind === 'base64' ? { format: 'base64' } :
                check.kind === 'base64url' ? { format: 'base64url' } :
                    check.kind === 'cidr' ? { format: check.version === 'v4' ? 'cidrv4' : check.version === 'v6' ? 'cidrv6' : 'cidr' } :
                        check.kind === 'cuid' ? { format: 'cuid' } :
                            check.kind === 'cuid2' ? { format: 'cuid2' } :
                                check.kind === 'date' ? { format: 'date' } :
                                    check.kind === 'datetime' ? { format: 'datetime' } :
                                        check.kind === 'duration' ? { format: 'duration' } :
                                            check.kind === 'email' ? { format: 'email' } :
                                                check.kind === 'emoji' ? { format: 'emoji' } :
                                                    check.kind === 'endsWith' ? { pattern: `${check.value}$` } :
                                                        check.kind === 'includes' ? { pattern: check.value } :
                                                            check.kind === 'ip' ? { format: check.version === 'v4' ? 'ipv4' : check.version === 'v6' ? 'ipv6' : 'ip' } :
                                                                check.kind === 'jwt' ? { format: 'jwt' } :
                                                                    check.kind === 'length' ? { minLength: check.value, maxLength: check.value } :
                                                                        check.kind === 'min' ? { minLength: check.value } :
                                                                            check.kind === 'max' ? { maxLength: check.value } :
                                                                                check.kind === 'nanoid' ? { format: 'nanoid' } :
                                                                                    check.kind === 'regex' ? { pattern: check.regex.source } :
                                                                                        check.kind === 'startsWith' ? { pattern: `^${check.value}` } :
                                                                                            check.kind === 'time' ? { format: 'time' } :
                                                                                                check.kind === 'ulid' ? { format: 'ulid' } :
                                                                                                    check.kind === 'url' ? { format: 'url' } :
                                                                                                        check.kind === 'uuid' ? { format: 'uuid' } :
                                                                                                            {}) };
    }, {});
    return t.String(options);
}
function FromSymbol(def) {
    return t.Symbol();
}
function FromTuple(def) {
    return t.Tuple(def.items.map((item) => FromType(item)));
}
function FromUndefined(def) {
    return t.Undefined();
}
function FromUnion(def) {
    return t.Union(def.options.map((item) => FromType(item)));
}
function FromUnknown(def) {
    return t.Unknown();
}
function FromVoid(def) {
    return t.Void();
}
// prettier-ignore
function FromType(type) {
    const schema = (type instanceof z.ZodAny ? FromAny(type._def) :
        type instanceof z.ZodArray ? FromArray(type._def) :
            type instanceof z.ZodBigInt ? FromBigInt(type._def) :
                type instanceof z.ZodBoolean ? FromBoolean(type._def) :
                    type instanceof z.ZodDate ? FromDate(type._def) :
                        type instanceof z.ZodDefault ? FromDefault(type._def) :
                            type instanceof z.ZodDiscriminatedUnion ? FromDiscriminatedUnion(type._def) :
                                type instanceof z.ZodEffects ? FromEffects(type) :
                                    type instanceof z.ZodEnum ? FromEnum(type._def) :
                                        type instanceof z.ZodLiteral ? FromLiteral(type._def) :
                                            type instanceof z.ZodNullable ? FromNullable(type._def) :
                                                type instanceof z.ZodObject ? FromObject(type._def, type.shape) :
                                                    type instanceof z.ZodOptional ? FromOptional(type._def) :
                                                        type instanceof z.ZodPromise ? FromPromise(type._def) :
                                                            type instanceof z.ZodReadonly ? FromReadonly(type._def) :
                                                                type instanceof z.ZodRecord ? FromRecord(type._def) :
                                                                    type instanceof z.ZodNever ? FromNever(type._def) :
                                                                        type instanceof z.ZodNull ? FromNull(type._def) :
                                                                            type instanceof z.ZodNumber ? FromNumber(type._def) :
                                                                                type instanceof z.ZodString ? FromString(type._def) :
                                                                                    type instanceof z.ZodSymbol ? FromSymbol(type._def) :
                                                                                        type instanceof z.ZodTuple ? FromTuple(type._def) :
                                                                                            type instanceof z.ZodUndefined ? FromUndefined(type._def) :
                                                                                                type instanceof z.ZodUnion ? FromUnion(type._def) :
                                                                                                    type instanceof z.ZodUnknown ? FromUnknown(type._def) :
                                                                                                        type instanceof z.ZodVoid ? FromVoid(type._def) :
                                                                                                            // Intersection (Ensure Last Due to Zod Differentiation Issue)
                                                                                                            type instanceof z.ZodIntersection ? FromIntersect(type._def) :
                                                                                                                t.Never());
    return t.CreateType(schema, Options(type));
}
/** Creates a TypeBox type from Zod */
// prettier-ignore
export function TypeBoxFromZod(type) {
    return FromType(type);
}
