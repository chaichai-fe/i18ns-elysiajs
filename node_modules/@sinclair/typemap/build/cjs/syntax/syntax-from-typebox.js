"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SyntaxFromTypeBox = SyntaxFromTypeBox;
const t = require("@sinclair/typebox");
const Ampersand = '&';
const Comma = ',';
const Pipe = '|';
function FromDelimited(values, delimiter) {
    return values.join(delimiter);
}
function FromAny(_type) {
    return 'any';
}
function FromArray(type) {
    return `${FromType(type)}[]`;
}
function FromBigInt(_type) {
    return 'bigint';
}
function FromBoolean(_type) {
    return 'boolean';
}
// prettier-ignore
function FromConstructor(parameters, instanceType) {
    const mappedParameters = FromParameters(parameters);
    const mappedInstanceType = FromType(instanceType);
    return `new ${mappedParameters} => ${mappedInstanceType}`;
}
// prettier-ignore
function FromFunction(parameters, returnType) {
    const mappedParameters = FromParameters(parameters);
    const mappedReturnType = FromType(returnType);
    return `${mappedParameters} => ${mappedReturnType}`;
}
function FromInteger(_type) {
    return 'integer';
}
function FromIntersect(types) {
    const result = types.map((type) => FromType(type));
    return `(${FromDelimited(result, ` ${Ampersand} `)})`;
}
// prettier-ignore
function FromLiteral(value) {
    return t.ValueGuard.IsString(value) ? `"${value}"` : `${value}`;
}
function FromNumber(_type) {
    return 'number';
}
function FromNull(_type) {
    return 'null';
}
function FromObject(properties) {
    const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);
    const delimited = FromProperties(propertyKeys, properties);
    const result = FromDelimited(delimited, `${Comma} `);
    return `{ ${result} }`;
}
function FromParameters(parameters) {
    const result = parameters.map((parameter, index) => `arg${index}: ${FromType(parameter)}`);
    return `(${FromDelimited(result, `${Comma} `)})`;
}
// prettier-ignore
function FromProperty(key, type) {
    const isOptional = t.KindGuard.IsOptional(type);
    const isReadonly = t.KindGuard.IsReadonly(type);
    const mapped = FromType(type);
    return (isReadonly && isOptional ? `readonly ${key}?: ${mapped}` :
        !isReadonly && isOptional ? `${key}?: ${mapped}` :
            isReadonly && !isOptional ? `readonly ${key}: ${mapped}` :
                `${key}: ${mapped}`);
}
// prettier-ignore
function FromProperties(propertyKeys, properties) {
    return propertyKeys.reduce((result, left) => {
        const key = t.ValueGuard.IsString(left) || t.ValueGuard.IsNumber(left) || t.ValueGuard.IsBoolean(left) ? `${left}` : undefined;
        return (t.ValueGuard.IsString(key)
            ? (key in properties
                ? [...result, FromProperty(key, properties[key])]
                : result) : result);
    }, []);
}
function FromPromise(type) {
    return `Promise<${FromType(type)}>`;
}
function FromString(_type) {
    return 'string';
}
function FromSymbol(_type) {
    return 'symbol';
}
function FromTuple(types) {
    const result = types.map((type) => FromType(type));
    return `[${FromDelimited(result, `${Comma} `)}]`;
}
function FromUndefined(type) {
    return 'undefined';
}
function FromUnion(types) {
    const result = types.map((type) => FromType(type));
    return `(${FromDelimited(result, ` ${Pipe} `)})`;
}
function FromUnknown(type) {
    return 'unknown';
}
function FromVoid(type) {
    return 'void';
}
// prettier-ignore
function FromType(type) {
    return (t.KindGuard.IsAny(type) ? FromAny(type) :
        t.KindGuard.IsArray(type) ? FromArray(type.items) :
            t.KindGuard.IsBigInt(type) ? FromBigInt(type) :
                t.KindGuard.IsBoolean(type) ? FromBoolean(type) :
                    t.KindGuard.IsConstructor(type) ? FromConstructor(type.parameters, type.returns) :
                        t.KindGuard.IsFunction(type) ? FromFunction(type.parameters, type.returns) :
                            t.KindGuard.IsInteger(type) ? FromInteger(type) :
                                t.KindGuard.IsIntersect(type) ? FromIntersect(type.allOf) :
                                    t.KindGuard.IsLiteral(type) ? FromLiteral(type.const) :
                                        t.KindGuard.IsNumber(type) ? FromNumber(type) :
                                            t.KindGuard.IsNull(type) ? FromNull(type) :
                                                t.KindGuard.IsObject(type) ? FromObject(type.properties) :
                                                    t.KindGuard.IsPromise(type) ? FromPromise(type.item) :
                                                        t.KindGuard.IsString(type) ? FromString(type) :
                                                            t.KindGuard.IsSymbol(type) ? FromSymbol(type) :
                                                                t.KindGuard.IsTuple(type) ? FromTuple(type.items || []) :
                                                                    t.KindGuard.IsUndefined(type) ? FromUndefined(type) :
                                                                        t.KindGuard.IsUnion(type) ? FromUnion(type.anyOf) :
                                                                            t.KindGuard.IsUnknown(type) ? FromUnknown(type) :
                                                                                t.KindGuard.IsVoid(type) ? FromVoid(type) :
                                                                                    'never');
}
function SyntaxFromTypeBox(type) {
    return FromType(type);
}
