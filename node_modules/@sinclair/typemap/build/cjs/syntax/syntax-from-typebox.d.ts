import * as t from '@sinclair/typebox';
type TEmptyString = '';
type TAmpersand = '&';
type TComma = ',';
type TPipe = '|';
type TFromDelimited<Values extends string[], Delimiter extends string, Result extends string = TEmptyString> = (Values extends [infer Left extends string, ...infer Right extends string[]] ? Result extends TEmptyString ? TFromDelimited<Right, Delimiter, Left> : TFromDelimited<Right, Delimiter, `${Result}${Delimiter} ${Left}`> : Result);
type TFromAny<_Type extends t.TAny> = 'any';
type TFromArray<Type extends t.TSchema, Result extends string = `${TFromType<Type>}[]`> = Result;
type TFromBigInt<_Type extends t.TBigInt> = 'bigint';
type TFromBoolean<_Type extends t.TBoolean> = 'boolean';
type TFromConstructor<Parameters extends t.TSchema[], InstanceType extends t.TSchema, MappedParameters extends string = TFromParameters<Parameters>, MappedInstanceType extends string = TFromType<InstanceType>> = `new ${MappedParameters} => ${MappedInstanceType}`;
type TFromFunction<Parameters extends t.TSchema[], ReturnType extends t.TSchema, MappedParameters extends string = TFromParameters<Parameters>, MappedReturnType extends string = TFromType<ReturnType>> = `${MappedParameters} => ${MappedReturnType}`;
type TFromInteger<_Type extends t.TInteger> = 'integer';
type TFromIntersect<Types extends t.TSchema[], Result extends string[] = []> = (Types extends [infer Left extends t.TSchema, ...infer Right extends t.TSchema[]] ? TFromIntersect<Right, [...Result, TFromType<Left>]> : `(${TFromDelimited<Result, ` ${TAmpersand}`>})`);
type TFromLiteral<Value extends t.TLiteralValue, Result extends string = Value extends string ? `"${Value}"` : `${Value}`> = Result;
type TFromNumber<_Type extends t.TNumber> = 'number';
type TFromNull<_Type extends t.TNull> = 'null';
type TFromObject<Properties extends t.TProperties, PropertyKeys extends PropertyKey[] = t.UnionToTuple<keyof Properties>, Delimited extends string[] = TFromProperties<PropertyKeys, Properties>, Result extends string = TFromDelimited<Delimited, TComma>> = `{ ${Result} }`;
type TFromParameters<Parameters extends t.TSchema[], Index extends string = '0', Result extends string[] = []> = (Parameters extends [infer Left extends t.TSchema, ...infer Right extends t.TSchema[]] ? TFromParameters<Right, t.TIncrement<Index>, [...Result, `arg${Index}: ${TFromType<Left>}`]> : `(${TFromDelimited<Result, TComma>})`);
type TFromProperty<Key extends string, Type extends t.TSchema, IsOptional extends boolean = Type extends t.TOptional<t.TSchema> ? true : false, IsReadonly extends boolean = Type extends t.TReadonly<t.TSchema> ? true : false, Mapped extends string = TFromType<Type>, Result = ([
    IsReadonly,
    IsOptional
] extends [true, true] ? `readonly ${Key}?: ${Mapped}` : [
    IsReadonly,
    IsOptional
] extends [false, true] ? `${Key}?: ${Mapped}` : [
    IsReadonly,
    IsOptional
] extends [true, false] ? `readonly ${Key}: ${Mapped}` : `${Key}: ${Mapped}`)> = Result;
type TFromProperties<PropertyKeys extends PropertyKey[], Properties extends t.TProperties, Result extends string[] = []> = (PropertyKeys extends [infer Left extends PropertyKey, ...infer Right extends PropertyKey[]] ? (Left extends infer Key extends string ? (Key extends keyof Properties ? TFromProperties<Right, Properties, [...Result, TFromProperty<Key, Properties[Key]>]> : TFromProperties<Right, Properties, Result>) : TFromProperties<Right, Properties, Result>) : Result);
type TFromPromise<Type extends t.TSchema, Result extends string = `Promise<${TFromType<Type>}>`> = Result;
type TFromString<_Type extends t.TString> = 'string';
type TFromSymbol<_Type extends t.TSymbol> = 'symbol';
type TFromTuple<Types extends t.TSchema[], Result extends string[] = []> = (Types extends [infer Left extends t.TSchema, ...infer Right extends t.TSchema[]] ? TFromTuple<Right, [...Result, TFromType<Left>]> : `[${TFromDelimited<Result, TComma>}]`);
type TFromUndefined<_Type extends t.TUndefined> = 'undefined';
type TFromUnion<Types extends t.TSchema[], Result extends string[] = []> = (Types extends [infer Left extends t.TSchema, ...infer Right extends t.TSchema[]] ? TFromUnion<Right, [...Result, TFromType<Left>]> : `(${TFromDelimited<Result, ` ${TPipe}`>})`);
type TFromUnknown<Type extends t.TSchema> = 'unknown';
type TFromVoid<Type extends t.TSchema> = 'void';
type TFromType<Type extends t.TSchema> = (Type extends t.TAny ? TFromAny<Type> : Type extends t.TArray<infer Type extends t.TSchema> ? TFromArray<Type> : Type extends t.TBigInt ? TFromBigInt<Type> : Type extends t.TBoolean ? TFromBoolean<Type> : Type extends t.TConstructor<infer Parameters extends t.TSchema[], infer InstanceType extends t.TSchema> ? TFromConstructor<Parameters, InstanceType> : Type extends t.TFunction<infer Parameters extends t.TSchema[], infer ReturnType extends t.TSchema> ? TFromFunction<Parameters, ReturnType> : Type extends t.TInteger ? TFromInteger<Type> : Type extends t.Intersect<infer Types extends t.TSchema[]> ? TFromIntersect<Types> : Type extends t.TLiteral<infer Value extends t.TLiteralValue> ? TFromLiteral<Value> : Type extends t.TNumber ? TFromNumber<Type> : Type extends t.TNull ? TFromNull<Type> : Type extends t.TObject<infer Properties extends t.TProperties> ? TFromObject<Properties> : Type extends t.TPromise<infer Type extends t.TSchema> ? TFromPromise<Type> : Type extends t.TString ? TFromString<Type> : Type extends t.TSymbol ? TFromSymbol<Type> : Type extends t.TTuple<infer Types extends t.TSchema[]> ? TFromTuple<Types> : Type extends t.TUndefined ? TFromUndefined<Type> : Type extends t.TUnion<infer Types extends t.TSchema[]> ? TFromUnion<Types> : Type extends t.TUnknown ? TFromUnknown<Type> : Type extends t.TVoid ? TFromVoid<Type> : 'never');
export type TSyntaxFromTypeBox<Type extends t.TSchema, Result extends string = TFromType<Type>> = Result;
export declare function SyntaxFromTypeBox<Type extends t.TSchema>(type: t.TSchema): TSyntaxFromTypeBox<Type>;
export {};
