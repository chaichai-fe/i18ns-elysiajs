import * as t from '@sinclair/typebox';
import * as v from 'valibot';
type BaseSchema = v.BaseSchema<unknown, unknown, v.BaseIssue<unknown>>;
type BaseRecordKey = v.BaseSchema<string, string | number | symbol, v.BaseIssue<unknown>>;
type TFromAny<_Type extends v.AnySchema> = t.Ensure<t.TAny>;
type TFromArray<Type extends BaseSchema> = t.Ensure<t.TArray<TFromType<Type>>>;
type TFromBigInt<_Type extends v.BigintSchema<any>> = t.Ensure<t.TBigInt>;
interface TBlob<Type extends v.BlobSchema<any> = v.BlobSchema<any>> extends t.TSchema {
    [t.Kind]: 'ValibotBlob';
    static: v.InferOutput<this['type']>;
    type: Type;
}
type TFromBlob<Type extends v.BlobSchema<any>> = t.Ensure<TBlob<Type>>;
type TFromBoolean<_Type extends v.BooleanSchema<any>> = t.TBoolean;
interface TCustom<Type extends v.CustomSchema<any, any> = v.CustomSchema<any, any>> extends t.TSchema {
    [t.Kind]: 'ValibotCustom';
    static: v.InferOutput<this['type']>;
    type: Type;
}
type TFromCustom<Type extends v.CustomSchema<any, any>> = t.Ensure<TCustom<Type>>;
type TFromDate<_Type extends v.DateSchema<any>> = t.TDate;
export interface TValibotEnum<Type extends v.EnumSchema<v.Enum, any> = v.EnumSchema<v.Enum, any>> extends t.TSchema {
    [t.Kind]: 'ValibotEnum';
    static: v.InferOutput<this['type']>;
    type: Type;
}
type TFromEnum<Enum extends v.EnumSchema<v.Enum, any>, Result = TValibotEnum<Enum>> = Result;
export interface TValibotFile<Type extends v.FileSchema<any> = v.FileSchema<any>> extends t.TSchema {
    [t.Kind]: 'ValibotFile';
    static: v.InferOutput<this['type']>;
    type: Type;
}
type TFromFile<Type extends v.FileSchema<any>> = t.Ensure<TValibotFile<Type>>;
export interface TValibotFunction<Type extends v.FunctionSchema<any> = v.FunctionSchema<any>> extends t.TSchema {
    [t.Kind]: 'ValibotFunction';
    static: v.InferOutput<this['type']>;
    type: Type;
}
type TFromFunction<Type extends v.FunctionSchema<any>> = t.Ensure<TValibotFunction<Type>>;
export interface TValibotInstance<Type extends v.InstanceSchema<v.Class, any> = v.InstanceSchema<v.Class, any>> extends t.TSchema {
    [t.Kind]: 'ValibotInstance';
    static: v.InferOutput<this['type']>;
    type: Type;
}
type TFromInstance<Type extends v.InstanceSchema<v.Class, any>> = t.Ensure<TValibotInstance<Type>>;
type TFromIntersect<Type extends BaseSchema[], Result extends t.TSchema[] = []> = (Type extends [infer Left extends BaseSchema, ...infer Right extends BaseSchema[]] ? TFromIntersect<Right, [...Result, TFromType<Left>]> : t.TIntersect<Result>);
type TFromLiteral<Value extends t.TLiteralValue> = t.Ensure<t.TLiteral<Value>>;
type TFromLooseObject<Properties extends v.ObjectEntries> = t.Ensure<t.TObject<{
    -readonly [Key in keyof Properties]: TFromType<Properties[Key]>;
}>>;
export interface TValibotLooseTuple<Type extends v.LooseTupleSchema<BaseSchema[], any> = v.LooseTupleSchema<BaseSchema[], any>> extends t.TSchema {
    [t.Kind]: 'ValibotLooseTuple';
    static: v.InferOutput<this['type']>;
    type: Type;
}
type TFromLooseTuple<Type extends v.LooseTupleSchema<BaseSchema[], any>> = t.Ensure<TValibotLooseTuple<Type>>;
export interface TValibotMap<Type extends v.MapSchema<BaseSchema, BaseSchema, any> = v.MapSchema<BaseSchema, BaseSchema, any>> extends t.TSchema {
    [t.Kind]: 'ValibotMap';
    static: v.InferOutput<this['type']>;
    type: Type;
}
type TFromMap<Type extends v.MapSchema<BaseSchema, BaseSchema, any>> = t.Ensure<TValibotMap<Type>>;
export interface TValibotNaN<Type extends v.NanSchema<any> = v.NanSchema<any>> extends t.TSchema {
    [t.Kind]: 'ValibotNaN';
    static: v.InferOutput<this['type']>;
    type: Type;
}
type TFromNaN<Type extends v.NanSchema<any>> = t.Ensure<TValibotNaN<Type>>;
type TFromNever<_Type extends v.NeverSchema<any>> = t.TNever;
type TFromNonNullable<Type extends BaseSchema> = t.TExclude<TFromType<Type>, t.TNull>;
type TFromNonNullish<Type extends BaseSchema> = t.TExclude<TFromType<Type>, t.TUnion<[t.TNull, t.TUndefined]>>;
type TFromNonOptional<Type extends BaseSchema, Result extends TFromType<Type> = TFromType<Type>> = t.TOptionalWithFlag<Result, false>;
type TFromNull<_Type extends v.NullSchema<any>> = t.TNull;
type TFromNullable<Type extends BaseSchema> = t.TUnion<[TFromType<Type>, t.TNull]>;
type TFromNullish<Type extends BaseSchema> = t.TUnion<[TFromType<Type>, t.TNull, t.TUndefined]>;
type TFromNumber<_Type extends v.NumberSchema<any>> = t.TNumber;
type TFromObject<Properties extends v.ObjectEntries> = t.Ensure<t.TObject<{
    -readonly [Key in keyof Properties]: TFromType<Properties[Key]>;
}>>;
type TFromObjectWithRest<Properties extends v.ObjectEntries, _Rest extends BaseSchema> = t.Ensure<t.TObject<{
    -readonly [Key in keyof Properties]: TFromType<Properties[Key]>;
}>>;
type TFromOptional<Type extends BaseSchema, Result extends TFromType<Type> = TFromType<Type>> = t.TOptionalWithFlag<Result, true>;
type PickListOption = string | number | bigint;
type TFromPickList<Options extends PickListOption[], Result extends t.TSchema[] = []> = (Options extends [infer Left extends PickListOption, ...infer Right extends PickListOption[]] ? (Left extends t.TLiteralValue ? TFromPickList<Right, [...Result, t.TLiteral<Left>]> : TFromPickList<Right, [...Result]>) : t.TUnion<Result>);
export interface TValibotPromise<Type extends v.PromiseSchema<any> = v.PromiseSchema<any>> extends t.TSchema {
    [t.Kind]: 'ValibotPromise';
    static: v.InferOutput<this['type']>;
    type: Type;
}
type TFromPromise<Type extends v.PromiseSchema<any>> = t.Ensure<TValibotPromise<Type>>;
type TFromRecord<Key extends BaseRecordKey, Value extends BaseSchema> = t.Ensure<t.TRecordOrObject<TFromType<Key>, TFromType<Value>>>;
export interface TValibotSet<Type extends v.SetSchema<BaseSchema, any> = v.SetSchema<BaseSchema, any>> extends t.TSchema {
    [t.Kind]: 'ValibotSet';
    static: v.InferOutput<this['type']> extends infer Result ? Result : never;
    type: Type;
}
type TFromSet<Type extends v.SetSchema<BaseSchema, any>> = t.Ensure<TValibotSet<Type>>;
type TFromStrictObject<Properties extends v.ObjectEntries> = t.Ensure<t.TObject<{
    -readonly [Key in keyof Properties]: TFromType<Properties[Key]>;
}>>;
type TFromStrictTuple<Type extends BaseSchema[], Result extends t.TSchema[] = []> = (Type extends [infer Left extends BaseSchema, ...infer Right extends BaseSchema[]] ? TFromTuple<Right, [...Result, TFromType<Left>]> : t.TTuple<Result>);
type TFromString<_Type extends v.StringSchema<any>> = t.TString;
type TFromSymbol<_Type extends v.SymbolSchema<any>> = t.TSymbol;
type TFromTuple<Type extends BaseSchema[], Result extends t.TSchema[] = []> = (Type extends [infer Left extends BaseSchema, ...infer Right extends BaseSchema[]] ? TFromTuple<Right, [...Result, TFromType<Left>]> : t.TTuple<Result>);
interface TTupleWithRest<Type extends v.TupleWithRestSchema<BaseSchema[], BaseSchema, any> = v.TupleWithRestSchema<BaseSchema[], BaseSchema, any>> extends t.TSchema {
    [t.Kind]: 'ValibotTupleWithRest';
    static: v.InferOutput<this['type']>;
    type: Type;
}
type TFromTupleWithRest<Type extends v.TupleWithRestSchema<BaseSchema[], BaseSchema, any>> = t.Ensure<TTupleWithRest<Type>>;
type TFromUndefined<_Type extends v.UndefinedSchema<any>> = t.TUndefined;
type TFromUndefinedable<Type extends BaseSchema> = t.TUnion<[TFromType<Type>, t.TUndefined]>;
type TFromUnion<Type extends BaseSchema[], Result extends t.TSchema[] = []> = (Type extends [infer Left extends BaseSchema, ...infer Right extends BaseSchema[]] ? TFromUnion<Right, [...Result, TFromType<Left>]> : t.TUnion<Result>);
type TFromUnknown<_Type extends v.UnknownSchema> = t.TUnknown;
interface TVariant<Type extends v.VariantSchema<string, v.VariantOptions<string>, any> = v.VariantSchema<string, v.VariantOptions<string>, any>> extends t.TSchema {
    [t.Kind]: 'ValibotVariant';
    static: v.InferOutput<this['type']>;
    type: Type;
}
type TFromVariant<Type extends v.VariantSchema<string, v.VariantOptions<string>, any>> = t.Ensure<TVariant<Type>>;
type TFromVoid<_Type extends v.VoidSchema<any>> = t.TVoid;
type TFromType<Type extends BaseSchema> = (Type extends {
    pipe: readonly [infer Type extends BaseSchema, ...any[]];
} ? TFromType<Type> : Type extends v.AnySchema ? TFromAny<Type> : Type extends v.ArraySchema<infer Type extends BaseSchema, any> ? TFromArray<Type> : Type extends v.BigintSchema<any> ? TFromBigInt<Type> : Type extends v.BlobSchema<any> ? TFromBlob<Type> : Type extends v.BooleanSchema<any> ? TFromBoolean<Type> : Type extends v.CustomSchema<unknown, any> ? TFromCustom<Type> : Type extends v.DateSchema<any> ? TFromDate<Type> : Type extends v.EnumSchema<any, any> ? TFromEnum<Type> : Type extends v.FileSchema<any> ? TFromFile<Type> : Type extends v.FunctionSchema<any> ? TFromFunction<Type> : Type extends v.InstanceSchema<v.Class, any> ? TFromInstance<Type> : Type extends v.IntersectSchema<infer Types extends BaseSchema[], any> ? TFromIntersect<Types> : Type extends v.LiteralSchema<infer Value extends t.TLiteralValue, any> ? TFromLiteral<Value> : Type extends v.LooseObjectSchema<infer Properties extends v.ObjectEntries, any> ? TFromLooseObject<Properties> : Type extends v.LooseTupleSchema<BaseSchema[], any> ? TFromLooseTuple<Type> : Type extends v.MapSchema<BaseSchema, BaseSchema, any> ? TFromMap<Type> : Type extends v.NanSchema<any> ? TFromNaN<Type> : Type extends v.NeverSchema<any> ? TFromNever<Type> : Type extends v.NonNullableSchema<infer Type extends BaseSchema, any> ? TFromNonNullable<Type> : Type extends v.NonNullishSchema<infer Type extends BaseSchema, any> ? TFromNonNullish<Type> : Type extends v.NonOptionalSchema<infer Type extends BaseSchema, any> ? TFromNonOptional<Type> : Type extends v.NullSchema<any> ? TFromNull<Type> : Type extends v.NullableSchema<infer Type extends BaseSchema, any> ? TFromNullable<Type> : Type extends v.NullishSchema<infer Type extends BaseSchema, any> ? TFromNullish<Type> : Type extends v.NumberSchema<any> ? TFromNumber<Type> : Type extends v.ObjectSchema<infer Properties extends v.ObjectEntries, any> ? TFromObject<Properties> : Type extends v.ObjectWithRestSchema<infer Properties extends v.ObjectEntries, infer Rest extends BaseSchema, any> ? TFromObjectWithRest<Properties, Rest> : Type extends v.OptionalSchema<infer Type extends BaseSchema, any> ? TFromOptional<Type> : Type extends v.PicklistSchema<infer Options extends PickListOption[], any> ? TFromPickList<Options> : Type extends v.PromiseSchema<any> ? TFromPromise<Type> : Type extends v.RecordSchema<infer Key extends BaseRecordKey, infer Value extends BaseSchema, any> ? TFromRecord<Key, Value> : Type extends v.SetSchema<BaseSchema, any> ? TFromSet<Type> : Type extends v.StrictObjectSchema<infer Properties extends v.ObjectEntries, any> ? TFromStrictObject<Properties> : Type extends v.StrictTupleSchema<infer Types extends BaseSchema[], any> ? TFromStrictTuple<Types> : Type extends v.StringSchema<any> ? TFromString<Type> : Type extends v.SymbolSchema<any> ? TFromSymbol<Type> : Type extends v.TupleSchema<infer Types extends BaseSchema[], any> ? TFromTuple<Types> : Type extends v.TupleWithRestSchema<BaseSchema[], BaseSchema, any> ? TFromTupleWithRest<Type> : Type extends v.UndefinedSchema<any> ? TFromUndefined<Type> : Type extends v.UndefinedableSchema<infer Type extends BaseSchema, any> ? TFromUndefinedable<Type> : Type extends v.UnionSchema<infer Types extends BaseSchema[], any> ? TFromUnion<Types> : Type extends v.UnknownSchema ? TFromUnknown<Type> : Type extends v.VariantSchema<string, v.VariantOptions<string>, any> ? TFromVariant<Type> : Type extends v.VoidSchema<any> ? TFromVoid<Type> : t.TNever);
/** Creates a TypeBox type from Valibot */
export type TTypeBoxFromValibot<Type extends v.BaseSchema<any, any, any>, Result extends t.TSchema = TFromType<Type>> = Result;
/** Creates a TypeBox type from Valibot */
export declare function TypeBoxFromValibot<Type extends v.BaseSchema<any, any, any>, Result extends TTypeBoxFromValibot<Type> = TTypeBoxFromValibot<Type>>(type: Type): Result;
export {};
