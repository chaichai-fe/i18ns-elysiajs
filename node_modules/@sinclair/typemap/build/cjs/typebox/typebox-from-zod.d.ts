import * as t from '@sinclair/typebox';
import * as z from 'zod';
type TFromAny = t.TAny;
type TFromArray<Type extends z.ZodTypeAny> = t.Ensure<t.TArray<TFromType<Type>>>;
type TFromBigInt = t.TBigInt;
type TFromBoolean = t.TBoolean;
type TFromDate = t.TDate;
type TFromDefault<Type extends z.ZodType> = TFromType<Type>;
type TFromDiscriminatedUnion<Discriminator extends string, Types extends readonly z.ZodObject<any>[], Result extends t.TSchema[] = []> = (Types extends [infer Left extends z.ZodObject<any>, ...infer Right extends z.ZodObject<any>[]] ? TFromDiscriminatedUnion<Discriminator, Right, [...Result, TFromType<Left>]> : t.TUnion<Result>);
type TFromEffects<Input extends z.ZodTypeAny, Output extends unknown> = t.Ensure<t.TTransform<TFromType<Input>, Output>>;
/** prettier-ignore */
type TFromEnum<Variants extends string[], Result extends t.TLiteral[] = []> = Variants extends [infer Left extends string, ...infer Right extends string[]] ? TFromEnum<Right, [...Result, t.TLiteral<Left>]> : t.TUnion<Result>;
type TFromLiteral<Value extends unknown> = t.Ensure<Value extends t.TLiteralValue ? t.TLiteral<Value> : t.TNever>;
type TFromIntersect<Types extends z.ZodTypeAny[], Result extends t.TSchema[] = []> = (Types extends [infer Left extends z.ZodTypeAny, ...infer Right extends z.ZodTypeAny[]] ? TFromIntersect<Right, [...Result, TFromType<Left>]> : t.Ensure<t.TIntersect<Result>>);
type TFromObject<Properties extends z.ZodRawShape> = t.Ensure<t.TObject<{
    [Key in keyof Properties]: TFromType<Properties[Key]>;
}>>;
type TFromOptional<Type extends z.ZodTypeAny, Result extends t.TSchema = t.TOptional<TFromType<Type>>> = Result;
type TFromPromise<Type extends z.ZodTypeAny> = t.Ensure<t.TPromise<TFromType<Type>>>;
type TFromNullable<Type extends z.ZodTypeAny> = t.Ensure<t.TUnion<[t.TNull, TFromType<Type>]>>;
type TFromNumber = t.TNumber;
type TFromNever = t.TNever;
type TFromNull = t.TNull;
type TFromReadonly<Type extends z.ZodTypeAny, Result extends t.TSchema = t.TReadonly<TFromType<Type>>> = Result;
type TFromRecord<Key extends z.ZodTypeAny, Value extends z.ZodTypeAny> = t.Ensure<t.TRecordOrObject<TFromType<Key>, TFromType<Value>>>;
type TFromString = t.TString;
type TFromSymbol = t.TSymbol;
type TFromTuple<Types extends z.ZodTypeAny[], Result extends t.TSchema[] = []> = (Types extends [infer Left extends z.ZodTypeAny, ...infer Right extends z.ZodTypeAny[]] ? TFromTuple<Right, [...Result, TFromType<Left>]> : t.TTuple<Result>);
type TFromUndefined = t.TUndefined;
type TFromUnion<Types extends z.ZodTypeAny[], Result extends t.TSchema[] = []> = (Types extends [infer Left extends z.ZodTypeAny, ...infer Right extends z.ZodTypeAny[]] ? TFromUnion<Right, [...Result, TFromType<Left>]> : t.TUnion<Result>);
type TFromUnknown = t.TUnknown;
type TFromVoid = t.TVoid;
type TFromType<Type extends z.ZodType> = (Type extends z.ZodAny ? TFromAny : Type extends z.ZodArray<infer Type> ? TFromArray<Type> : Type extends z.ZodBigInt ? TFromBigInt : Type extends z.ZodBoolean ? TFromBoolean : Type extends z.ZodDate ? TFromDate : Type extends z.ZodDefault<infer Type> ? TFromDefault<Type> : Type extends z.ZodDiscriminatedUnion<infer Discriminator, infer Types> ? TFromDiscriminatedUnion<Discriminator, Types> : Type extends z.ZodEffects<infer Input, infer Output> ? TFromEffects<Input, Output> : Type extends z.ZodEnum<infer Variants> ? TFromEnum<Variants> : Type extends z.ZodLiteral<infer Value> ? TFromLiteral<Value> : Type extends z.ZodNullable<infer Type> ? TFromNullable<Type> : Type extends z.ZodObject<infer Properties> ? TFromObject<Properties> : Type extends z.ZodOptional<infer Type> ? TFromOptional<Type> : Type extends z.ZodPromise<infer Type> ? TFromPromise<Type> : Type extends z.ZodRecord<infer Key, infer Value> ? TFromRecord<Key, Value> : Type extends z.ZodReadonly<infer Type> ? TFromReadonly<Type> : Type extends z.ZodNumber ? TFromNumber : Type extends z.ZodNever ? TFromNever : Type extends z.ZodNull ? TFromNull : Type extends z.ZodString ? TFromString : Type extends z.ZodSymbol ? TFromSymbol : Type extends z.ZodTuple<infer Types> ? TFromTuple<t.Assert<Types, z.ZodTypeAny[]>> : Type extends z.ZodUndefined ? TFromUndefined : Type extends z.ZodUnion<infer Types> ? TFromUnion<t.Assert<Types, z.ZodTypeAny[]>> : Type extends z.ZodUnknown ? TFromUnknown : Type extends z.ZodVoid ? TFromVoid : Type extends z.ZodIntersection<infer Left, infer Right> ? TFromIntersect<[Left, Right]> : t.TNever);
/** Creates a TypeBox type from Zod */
export type TTypeBoxFromZod<Type extends z.ZodTypeAny | z.ZodEffects<any>, Result extends t.TSchema = TFromType<Type>> = Result;
/** Creates a TypeBox type from Zod */
export declare function TypeBoxFromZod<Type extends z.ZodTypeAny | z.ZodEffects<any>>(type: Type): TTypeBoxFromZod<Type>;
export {};
