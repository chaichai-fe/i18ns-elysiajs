"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ValibotFromTypeBox = ValibotFromTypeBox;
const t = require("@sinclair/typebox");
const v = require("valibot");
// ------------------------------------------------------------------
// Constraints
// ------------------------------------------------------------------
function CreateConstraints(type, initial = []) {
    const constraints = [];
    if (t.ValueGuard.IsString(type.description))
        constraints.push(v.description(type.description));
    if (t.ValueGuard.IsString(type.title))
        constraints.push(v.title(type.title));
    if (t.ValueGuard.IsObject(type.metadata))
        constraints.push(v.metadata(type.metadata));
    return [...initial, ...constraints];
}
function CreateType(type, constraints = []) {
    return constraints.length === 0 ? type : v.pipe(type, ...constraints);
}
function FromAny(type) {
    return CreateType(v.any(), CreateConstraints(type));
}
function FromArray(type) {
    const { minItems, maxItems /* minContains, maxContains, contains */ } = type;
    const constraints = CreateConstraints(type);
    if (t.ValueGuard.IsNumber(minItems))
        constraints.push(v.minLength(minItems));
    if (t.ValueGuard.IsNumber(maxItems))
        constraints.push(v.maxLength(maxItems));
    const mapped = v.array(FromType(type.items));
    return CreateType(mapped, constraints);
}
function FromBigInt(type) {
    return CreateType(v.bigint(), CreateConstraints(type));
}
function FromBoolean(type) {
    return CreateType(v.boolean(), CreateConstraints(type));
}
function FromDate(type) {
    return CreateType(v.date(), CreateConstraints(type));
}
function FromFunction(type) {
    return CreateType(v.function(), CreateConstraints(type));
}
function FromInteger(type) {
    const { exclusiveMaximum, exclusiveMinimum, minimum, maximum, multipleOf } = type;
    const constraints = CreateConstraints(type, [v.integer()]);
    if (t.ValueGuard.IsNumber(exclusiveMinimum))
        constraints.push(v.minValue(exclusiveMinimum + 1));
    if (t.ValueGuard.IsNumber(exclusiveMaximum))
        constraints.push(v.minValue(exclusiveMaximum - 1));
    if (t.ValueGuard.IsNumber(maximum))
        constraints.push(v.maxValue(maximum));
    if (t.ValueGuard.IsNumber(minimum))
        constraints.push(v.minValue(minimum));
    if (t.ValueGuard.IsNumber(multipleOf))
        constraints.push(v.multipleOf(multipleOf));
    return CreateType(v.number(), constraints);
}
function FromIntersect(type) {
    const schemas = type.allOf.map((schema) => FromType(schema));
    return CreateType(v.intersect(schemas), CreateConstraints(type));
}
function FromLiteral(type) {
    return CreateType(v.literal(type.const), CreateConstraints(type));
}
// prettier-ignore
function FromObject(type) {
    const { additionalProperties } = type;
    const constraints = CreateConstraints(type);
    const properties = globalThis.Object.getOwnPropertyNames(type.properties).reduce((result, key) => ({ ...result, [key]: FromType(type.properties[key]) }), {});
    return additionalProperties === false
        ? CreateType(v.strictObject(properties), constraints) // facade
        : CreateType(v.object(properties), constraints);
}
function FromPromise(type) {
    return CreateType(v.promise(), CreateConstraints(type));
}
function FromRegExp(type) {
    const { minLength, maxLength } = type;
    const constraints = CreateConstraints(type, [v.regex(new RegExp(type.source, type.flags))]);
    if (t.ValueGuard.IsNumber(maxLength))
        constraints.push(v.maxLength(maxLength));
    if (t.ValueGuard.IsNumber(minLength))
        constraints.push(v.minLength(minLength));
    return CreateType(v.string(), constraints);
}
// prettier-ignore
function FromRecord(type) {
    const constraints = CreateConstraints(type);
    const pattern = globalThis.Object.getOwnPropertyNames(type.patternProperties)[0];
    const value = FromType(type.patternProperties[pattern]);
    return (pattern === t.PatternStringExact
        ? CreateType(v.record(v.string(), value), constraints)
        : CreateType(v.record(v.pipe(v.string(), v.regex(new RegExp(pattern))), value), constraints));
}
function FromNever(type) {
    return CreateType(v.never(), CreateConstraints(type));
}
function FromNull(type) {
    return CreateType(v.null(), CreateConstraints(type));
}
function FromNumber(type) {
    const { exclusiveMaximum, exclusiveMinimum, minimum, maximum, multipleOf } = type;
    const constraints = CreateConstraints(type);
    if (t.ValueGuard.IsNumber(exclusiveMinimum))
        constraints.push(v.minValue(exclusiveMinimum + 1));
    if (t.ValueGuard.IsNumber(exclusiveMaximum))
        constraints.push(v.minValue(exclusiveMaximum - 1));
    if (t.ValueGuard.IsNumber(maximum))
        constraints.push(v.maxValue(maximum));
    if (t.ValueGuard.IsNumber(minimum))
        constraints.push(v.minValue(minimum));
    if (t.ValueGuard.IsNumber(multipleOf))
        constraints.push(v.multipleOf(multipleOf));
    return CreateType(v.number(), constraints);
}
// prettier-ignore
function FromString(type) {
    const { minLength, maxLength, pattern, format } = type;
    const constraints = CreateConstraints(type);
    if (t.ValueGuard.IsNumber(maxLength))
        constraints.push(v.maxLength(maxLength));
    if (t.ValueGuard.IsNumber(minLength))
        constraints.push(v.minLength(minLength));
    if (t.ValueGuard.IsString(pattern))
        constraints.push(v.regex(new RegExp(pattern)));
    if (t.ValueGuard.IsString(format))
        constraints.push(...(format === 'base64' ? [v.base64()] :
            format === 'bic' ? [v.bic()] :
                format === 'credit_card' ? [v.creditCard()] :
                    format === 'cuid2' ? [v.cuid2()] :
                        format === 'decimal' ? [v.decimal()] :
                            format === 'digits' ? [v.digits()] :
                                format === 'email' ? [v.email()] :
                                    format === 'emoji' ? [v.emoji()] :
                                        format === 'ip' ? [v.ip()] :
                                            format === 'ipv4' ? [v.ipv4()] :
                                                format === 'ipv6' ? [v.ipv6()] :
                                                    format === 'iso_date' ? [v.isoDate()] :
                                                        format === 'iso_date_time' ? [v.isoDateTime()] :
                                                            format === 'iso_time' ? [v.isoTime()] :
                                                                format === 'iso_time_second' ? [v.isoTimeSecond()] :
                                                                    format === 'iso_timestamp' ? [v.isoTimestamp()] :
                                                                        format === 'iso_week' ? [v.isoWeek()] :
                                                                            format === 'mac' ? [v.mac()] :
                                                                                format === 'mac48' ? [v.mac48()] :
                                                                                    format === 'mac64' ? [v.mac64()] :
                                                                                        format === 'nanoid' ? [v.nanoid()] :
                                                                                            format === 'octal' ? [v.octal()] :
                                                                                                format === 'ulid' ? [v.ulid()] :
                                                                                                    format === 'url' ? [v.url()] :
                                                                                                        format === 'uuid' ? [v.uuid()] :
                                                                                                            []));
    return CreateType(v.string(), constraints);
}
function FromSymbol(type) {
    return CreateType(v.symbol(), CreateConstraints(type));
}
function FromTuple(type) {
    const mapped = FromTypes(type.items || []);
    return CreateType(v.tuple(mapped), CreateConstraints(type));
}
function FromUndefined(type) {
    return CreateType(v.undefined(), CreateConstraints(type));
}
function FromUnion(type) {
    const mapped = FromTypes(type.anyOf);
    return CreateType(v.union(mapped), CreateConstraints(type));
}
function FromUnknown(type) {
    return CreateType(v.unknown(), CreateConstraints(type));
}
function FromVoid(type) {
    return CreateType(v.void(), CreateConstraints(type));
}
function FromTypes(types) {
    return types.map((type) => FromType(type));
}
// prettier-ignore
function FromType(type) {
    // Type Mapping
    const mapped = (t.KindGuard.IsAny(type) ? FromAny(type) :
        t.KindGuard.IsArray(type) ? FromArray(type) :
            t.KindGuard.IsBigInt(type) ? FromBigInt(type) :
                t.KindGuard.IsBoolean(type) ? FromBoolean(type) :
                    t.KindGuard.IsDate(type) ? FromDate(type) :
                        t.KindGuard.IsFunction(type) ? FromFunction(type) :
                            t.KindGuard.IsInteger(type) ? FromInteger(type) :
                                t.KindGuard.IsIntersect(type) ? FromIntersect(type) :
                                    t.KindGuard.IsLiteral(type) ? FromLiteral(type) :
                                        t.KindGuard.IsNever(type) ? FromNever(type) :
                                            t.KindGuard.IsNull(type) ? FromNull(type) :
                                                t.KindGuard.IsNumber(type) ? FromNumber(type) :
                                                    t.KindGuard.IsObject(type) ? FromObject(type) :
                                                        t.KindGuard.IsPromise(type) ? FromPromise(type) :
                                                            t.KindGuard.IsRegExp(type) ? FromRegExp(type) :
                                                                t.KindGuard.IsRecord(type) ? FromRecord(type) :
                                                                    t.KindGuard.IsString(type) ? FromString(type) :
                                                                        t.KindGuard.IsSymbol(type) ? FromSymbol(type) :
                                                                            t.KindGuard.IsTuple(type) ? FromTuple(type) :
                                                                                t.KindGuard.IsUndefined(type) ? FromUndefined(type) :
                                                                                    t.KindGuard.IsUnion(type) ? FromUnion(type) :
                                                                                        t.KindGuard.IsUnknown(type) ? FromUnknown(type) :
                                                                                            t.KindGuard.IsVoid(type) ? FromVoid(type) :
                                                                                                v.never());
    // Modifier Mapping
    const isOptional = t.KindGuard.IsOptional(type);
    const isReadonly = t.KindGuard.IsReadonly(type);
    const result = (isOptional && isReadonly ? v.optional(mapped) :
        isOptional && !isReadonly ? v.optional(mapped) :
            !isOptional && isReadonly ? mapped :
                mapped);
    return result;
}
// prettier-ignore
function ValibotFromTypeBox(type) {
    return FromType(type);
}
