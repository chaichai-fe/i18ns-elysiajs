import * as t from '@sinclair/typebox';
import * as v from 'valibot';
import * as c from './common';
type TFromAny<Result = v.AnySchema> = Result;
type TFromArray<Type extends t.TSchema, Result = v.ArraySchema<TFromType<Type>, c.BaseError>> = Result;
type TFromBigInt<Result = v.BigintSchema<c.BaseError>> = Result;
type TFromBoolean<Result = v.BooleanSchema<c.BaseError>> = Result;
type TFromDate<Result = v.DateSchema<c.BaseError>> = Result;
type TFromFunction<Parameters extends t.TSchema[], ReturnType extends t.TSchema> = (v.FunctionSchema<any>);
type TFromInteger<Result = v.NumberSchema<c.BaseError>> = Result;
type TFromIntersect<Types extends t.TSchema[], Result extends c.BaseSchema[] = []> = (Types extends [infer Left extends t.TSchema, ...infer Right extends t.TSchema[]] ? TFromIntersect<Right, [...Result, TFromType<Left>]> : v.IntersectSchema<Result, any>);
type TFromLiteral<Value extends t.TLiteralValue, Result = v.LiteralSchema<Value, undefined>> = Result;
type TFromObject<Properties extends t.TProperties, Result = v.ObjectSchema<{
    [Key in keyof Properties]: TFromType<Properties[Key]>;
}, c.BaseError>> = Result;
type TFromPromise<_Type extends t.TSchema, Result = v.PromiseSchema<c.BaseError>> = Result;
type TFromRegExp<Result = v.StringSchema<c.BaseError>> = Result;
type TFromRecord<Key extends t.TSchema, Value extends t.TSchema> = (TFromType<Key> extends infer MappedKey extends c.BaseRecordKey ? v.RecordSchema<MappedKey, TFromType<Value>, c.BaseError> : v.RecordSchema<v.StringSchema<c.BaseError>, TFromType<Value>, c.BaseError>);
type TFromNever<Result = v.NeverSchema<c.BaseError>> = Result;
type TFromNull<Result = v.NullSchema<c.BaseError>> = Result;
type TFromNumber<Result = v.NumberSchema<c.BaseError>> = Result;
type TFromString<Result = v.StringSchema<c.BaseError>> = Result;
type TFromSymbol<Result = v.SymbolSchema<c.BaseError>> = Result;
type TFromTuple<Types extends t.TSchema[], Mapped extends c.BaseSchema[] = TFromTypes<Types>> = (v.TupleSchema<Mapped, c.BaseError>);
type TFromUndefined<Result = v.UndefinedSchema<c.BaseError>> = Result;
type TFromUnion<Types extends t.TSchema[], Mapped extends c.BaseSchema[] = TFromTypes<Types>, Result = v.UnionSchema<Mapped, c.BaseError>> = Result;
type TFromUnknown<Result = v.UnknownSchema> = Result;
type TFromVoid<Result = v.VoidSchema<c.BaseError>> = Result;
type TFromTypes<Types extends t.TSchema[], Result extends c.BaseSchema[] = []> = Types extends [infer Left extends t.TSchema, ...infer Right extends t.TSchema[]] ? TFromTypes<Right, [...Result, TFromType<Left>]> : Result;
type TFromType<Type extends t.TSchema, Mapped extends v.BaseSchema<any, any, any> = (Type extends t.TAny ? TFromAny : Type extends t.TArray<infer Type extends t.TSchema> ? TFromArray<Type> : Type extends t.TBigInt ? TFromBigInt : Type extends t.TBoolean ? TFromBoolean : Type extends t.TDate ? TFromDate : Type extends t.TFunction<infer Parameters extends t.TSchema[], infer ReturnType extends t.TSchema> ? TFromFunction<Parameters, ReturnType> : Type extends t.TInteger ? TFromInteger : Type extends t.TIntersect<infer Types extends t.TSchema[]> ? TFromIntersect<Types> : Type extends t.TLiteral<infer Value extends t.TLiteralValue> ? TFromLiteral<Value> : Type extends t.TNull ? TFromNull : Type extends t.TNever ? TFromNever : Type extends t.TNumber ? TFromNumber : Type extends t.TObject<infer Properties extends t.TProperties> ? TFromObject<Properties> : Type extends t.TPromise<infer Type extends t.TSchema> ? TFromPromise<Type> : Type extends t.TRecord<infer Key extends t.TSchema, infer Value extends t.TSchema> ? TFromRecord<Key, Value> : Type extends t.TRegExp ? TFromRegExp : Type extends t.TString ? TFromString : Type extends t.TSymbol ? TFromSymbol : Type extends t.TTuple<infer Types extends t.TSchema[]> ? TFromTuple<Types> : Type extends t.TUndefined ? TFromUndefined : Type extends t.TUnion<infer Types extends t.TSchema[]> ? TFromUnion<Types> : Type extends t.TUnknown ? TFromUnknown : Type extends t.TVoid ? TFromVoid : v.NeverSchema<c.BaseError>), IsReadonly extends boolean = Type extends t.TReadonly<t.TSchema> ? true : false, IsOptional extends boolean = Type extends t.TOptional<t.TSchema> ? true : false, Result extends v.BaseSchema<any, any, any> = ([
    IsReadonly,
    IsOptional
] extends [true, true] ? v.OptionalSchema<Mapped, c.BaseError> : [
    IsReadonly,
    IsOptional
] extends [false, true] ? v.OptionalSchema<Mapped, c.BaseError> : [
    IsReadonly,
    IsOptional
] extends [true, false] ? Mapped : Mapped)> = Result;
export type TValibotFromTypeBox<Type extends t.TSchema, Result extends c.BaseSchema = TFromType<Type>> = Result;
export declare function ValibotFromTypeBox<Type extends t.TSchema>(type: Type): TValibotFromTypeBox<Type>;
export {};
