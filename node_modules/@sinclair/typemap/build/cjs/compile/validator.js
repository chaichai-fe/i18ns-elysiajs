"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Validator = exports.StandardSchemaProps = void 0;
const value_1 = require("@sinclair/typebox/value");
const path_1 = require("./path");
// ------------------------------------------------------------------
// StandardSchemaProps<Input, Output>
// ------------------------------------------------------------------
// prettier-ignore
class StandardSchemaProps {
    constructor(check) {
        this.__check = check;
    }
    // ----------------------------------------------------------------
    // StandardSchemaV1.Props<Input, Output>
    // ----------------------------------------------------------------
    get vendor() {
        return '@sinclair/typemap';
    }
    get version() {
        return 1;
    }
    get types() {
        throw Error('types is a phantom property used for inference only.');
    }
    validate(value) {
        return (this.__check.Check(value) ? this.__createValue(value) : this.__createIssues(value));
    }
    // ----------------------------------------------------------------
    // Internal
    // ----------------------------------------------------------------
    __createIssues(value) {
        const errors = [...value_1.Value.Errors(this.__check.Schema(), value)];
        const issues = errors.map((error) => ({ ...error, path: (0, path_1.ZodPathFromJsonPointer)(error.path) }));
        return { issues };
    }
    __createValue(value) {
        return { value };
    }
}
exports.StandardSchemaProps = StandardSchemaProps;
// ------------------------------------------------------------------
// Validator<TSchema>
// ------------------------------------------------------------------
class Validator {
    constructor(check) {
        this.__standard = new StandardSchemaProps(check);
        this.__check = check;
    }
    /** Standard Schema Interface */
    get ['~standard']() {
        return this.__standard;
    }
    /** Returns the code used by this validator. */
    Code() {
        return this.__check.Code();
    }
    /** Parses this value. Do not use this function for high throughput validation */
    Parse(value) {
        return value_1.Value.Parse(this.__check.Schema(), value);
    }
    /** Checks if this value matches the type */
    Check(value) {
        return this.__check.Check(value);
    }
    /** Returns errors for this value */
    Errors(value) {
        return this.__check.Errors(value);
    }
}
exports.Validator = Validator;
