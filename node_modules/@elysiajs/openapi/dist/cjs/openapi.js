"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/openapi.ts
var openapi_exports = {};
__export(openapi_exports, {
  capitalize: () => capitalize,
  getLoosePath: () => getLoosePath,
  getPossiblePath: () => getPossiblePath,
  toOpenAPISchema: () => toOpenAPISchema,
  withHeaders: () => withHeaders
});
module.exports = __toCommonJS(openapi_exports);
var import_elysia = require("elysia");

// node_modules/@sinclair/typebox/build/esm/type/symbols/symbols.mjs
var TransformKind = Symbol.for("TypeBox.Transform");
var ReadonlyKind = Symbol.for("TypeBox.Readonly");
var OptionalKind = Symbol.for("TypeBox.Optional");
var Hint = Symbol.for("TypeBox.Hint");
var Kind = Symbol.for("TypeBox.Kind");

// src/openapi.ts
var capitalize = (word) => word.charAt(0).toUpperCase() + word.slice(1);
var toRef = (name) => import_elysia.t.Ref(`#/components/schemas/${name}`);
var toOperationId = (method, paths) => {
  let operationId = method.toLowerCase();
  if (!paths || paths === "/") return operationId + "Index";
  for (const path of paths.split("/"))
    operationId += path.includes(":") ? "By" + capitalize(path.replace(":", "")) : capitalize(path);
  operationId = operationId.replace(/\?/g, "Optional");
  return operationId;
};
var optionalParamsRegex = /(\/:\w+\?)/g;
var getPossiblePath = (path) => {
  const optionalParams = path.match(optionalParamsRegex);
  if (!optionalParams) return [path];
  const originalPath = path.replace(/\?/g, "");
  const paths = [originalPath];
  for (let i = 0; i < optionalParams.length; i++) {
    const newPath = path.replace(optionalParams[i], "");
    paths.push(...getPossiblePath(newPath));
  }
  return paths;
};
var isValidSchema = (schema) => typeof schema === "object" && (Kind in schema && schema[Kind] !== "Unknown" || schema.type || schema.properties || schema.items);
var getLoosePath = (path) => {
  if (path.charCodeAt(path.length - 1) === 47)
    return path.slice(0, path.length - 1);
  return path + "/";
};
function toOpenAPISchema(app, exclude, references) {
  const {
    methods: excludeMethods = ["OPTIONS"],
    staticFile: excludeStaticFile = true,
    tags: excludeTags
  } = exclude ?? {};
  const excludePaths = Array.isArray(exclude?.paths) ? exclude.paths : typeof exclude?.paths !== "undefined" ? [exclude.paths] : [];
  const paths = /* @__PURE__ */ Object.create(null);
  const routes = app.getGlobalRoutes();
  if (references) {
    if (!Array.isArray(references)) references = [references];
    for (let i = 0; i < references.length; i++) {
      const reference = references[i];
      if (typeof reference === "function") references[i] = reference();
    }
  }
  for (const route of routes) {
    if (route.hooks?.detail?.hide) continue;
    const method = route.method.toLowerCase();
    if (excludeStaticFile && route.path.includes(".") || excludePaths.includes(route.path) || excludeMethods.includes(method))
      continue;
    const hooks = route.hooks ?? {};
    if (references)
      for (const reference of references) {
        if (!reference) continue;
        const refer = reference[route.path]?.[method] ?? reference[getLoosePath(route.path)]?.[method];
        if (!refer) continue;
        if (!hooks.body && isValidSchema(refer.body))
          hooks.body = refer.body;
        if (!hooks.query && isValidSchema(refer.query))
          hooks.query = refer.query;
        if (!hooks.params && isValidSchema(refer.params))
          hooks.params = refer.params;
        if (!hooks.headers && isValidSchema(refer.headers))
          hooks.headers = refer.headers;
        if (refer.response) {
          for (const [status, schema] of Object.entries(
            refer.response
          ))
            if (isValidSchema(schema)) {
              if (!hooks.response) hooks.response = {};
              if (!hooks.response[status])
                hooks.response[status] = schema;
            }
        }
      }
    if (excludeTags && hooks.detail.tags?.some((tag) => excludeTags?.includes(tag)))
      continue;
    const operation = {
      ...hooks.detail
    };
    const parameters = [];
    if (hooks.params) {
      if (typeof hooks.params === "string")
        hooks.params = toRef(hooks.params);
      if (hooks.params.type === "object" && hooks.params.properties) {
        for (const [paramName, paramSchema] of Object.entries(
          hooks.params.properties
        ))
          parameters.push({
            name: paramName,
            in: "path",
            required: true,
            // Path parameters are always required
            schema: paramSchema
          });
      }
    }
    if (hooks.query) {
      if (typeof hooks.query === "string")
        hooks.query = toRef(hooks.query);
      if (hooks.query.type === "object" && hooks.query.properties) {
        const required = hooks.query.required || [];
        for (const [queryName, querySchema] of Object.entries(
          hooks.query.properties
        ))
          parameters.push({
            name: queryName,
            in: "query",
            required: required.includes(queryName),
            schema: querySchema
          });
      }
    }
    if (hooks.headers) {
      if (typeof hooks.headers === "string")
        hooks.headers = toRef(hooks.headers);
      if (hooks.headers.type === "object" && hooks.headers.properties) {
        const required = hooks.headers.required || [];
        for (const [headerName, headerSchema] of Object.entries(
          hooks.headers.properties
        ))
          parameters.push({
            name: headerName,
            in: "header",
            required: required.includes(headerName),
            schema: headerSchema
          });
      }
    }
    if (hooks.cookie) {
      if (typeof hooks.cookie === "string")
        hooks.cookie = toRef(hooks.cookie);
      if (hooks.cookie.type === "object" && hooks.cookie.properties) {
        const required = hooks.cookie.required || [];
        for (const [cookieName, cookieSchema] of Object.entries(
          hooks.cookie.properties
        ))
          parameters.push({
            name: cookieName,
            in: "cookie",
            required: required.includes(cookieName),
            schema: cookieSchema
          });
      }
    }
    if (parameters.length > 0) operation.parameters = parameters;
    if (hooks.body && method !== "get" && method !== "head") {
      if (typeof hooks.body === "string") hooks.body = toRef(hooks.body);
      if (hooks.parse) {
        const content = {};
        const parsers = hooks.parse;
        for (const parser of parsers) {
          if (typeof parser.fn === "function") continue;
          switch (parser.fn) {
            case "text":
            case "text/plain":
              content["text/plain"] = { schema: hooks.body };
              continue;
            case "urlencoded":
            case "application/x-www-form-urlencoded":
              content["application/x-www-form-urlencoded"] = {
                schema: hooks.body
              };
              continue;
            case "json":
            case "application/json":
              content["application/json"] = { schema: hooks.body };
              continue;
            case "formdata":
            case "multipart/form-data":
              content["multipart/form-data"] = {
                schema: hooks.body
              };
              continue;
          }
        }
        operation.requestBody = { content, required: true };
      } else {
        operation.requestBody = {
          content: {
            "application/json": {
              schema: hooks.body
            },
            "application/x-www-form-urlencoded": {
              schema: hooks.body
            },
            "multipart/form-data": {
              schema: hooks.body
            }
          },
          required: true
        };
      }
    }
    if (hooks.response) {
      operation.responses = {};
      if (typeof hooks.response === "object" && !hooks.response.type && !hooks.response.$ref) {
        for (let [status, schema] of Object.entries(hooks.response)) {
          if (typeof schema === "string") schema = toRef(schema);
          const { type, examples, $ref, ...options } = schema;
          operation.responses[status] = {
            description: `Response for status ${status}`,
            ...options,
            content: type === "void" || type === "null" || type === "undefined" ? schema : {
              "application/json": {
                schema
              }
            }
          };
        }
      } else {
        if (typeof hooks.response === "string")
          hooks.response = toRef(hooks.response);
        operation.responses["200"] = {
          description: "Successful response",
          content: {
            "application/json": {
              schema: hooks.response
            }
          }
        };
      }
    }
    for (let path of getPossiblePath(route.path)) {
      const operationId = toOperationId(route.method, path);
      path = path.replace(/:([^/]+)/g, "{$1}");
      if (!paths[path]) paths[path] = {};
      const current = paths[path];
      if (method !== "all") {
        current[method] = {
          ...operation,
          operationId
        };
        continue;
      }
      for (const method2 of [
        "get",
        "post",
        "put",
        "delete",
        "patch",
        "head",
        "options",
        "trace"
      ])
        current[method2] = {
          ...operation,
          operationId
        };
    }
  }
  const schemas = app.getGlobalDefinitions?.().type;
  return {
    components: {
      schemas
    },
    paths
  };
}
var withHeaders = (schema, headers) => Object.assign(schema, {
  headers
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  capitalize,
  getLoosePath,
  getPossiblePath,
  toOpenAPISchema,
  withHeaders
});
